# NodPT - Consolidated Copilot Instructions

This file consolidates all copilot instructions from across the NodPT repository to provide comprehensive context for AI-assisted development across all project components.

---

## üì¶ NodPT Repository Structure

```
NodPT/
‚îú‚îÄ‚îÄ Frontend/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.yml
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ components/
‚îÇ       ‚îú‚îÄ‚îÄ views/
‚îÇ       ‚îú‚îÄ‚îÄ service/
‚îÇ       ‚îú‚îÄ‚îÄ plugins/
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îú‚îÄ‚îÄ WebAPI/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.yml
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îî‚îÄ‚îÄ ... (C# .NET Web API)
‚îÇ
‚îú‚îÄ‚îÄ SignalR/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.yml
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îî‚îÄ‚îÄ ... (Real-time communication hub)
‚îÇ
‚îú‚îÄ‚îÄ Executor/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.yml
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îî‚îÄ‚îÄ ... (Task execution service)
‚îÇ
‚îú‚îÄ‚îÄ Redis/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îî‚îÄ‚îÄ ... (Caching and message broker)
‚îÇ
‚îú‚îÄ‚îÄ AI/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îî‚îÄ‚îÄ ... (AI processing service)
‚îÇ
‚îî‚îÄ‚îÄ .github/
    ‚îú‚îÄ‚îÄ workflows/
    ‚îÇ   ‚îú‚îÄ‚îÄ Frontend-deploy.yml
    ‚îÇ   ‚îú‚îÄ‚îÄ Backend-deploy.yml
    ‚îÇ   ‚îú‚îÄ‚îÄ SignalR-deploy.yml
    ‚îÇ   ‚îî‚îÄ‚îÄ (Executor-deploy.yml - to be added)
```

---

# Frontend Instructions

## üìÑ Overview
This project builds a visual AI-assisted workflow editor frontend using Vue 3, Rete.js, and Bootstrap 5. The goal is to create a clean, modular UI split into four main areas:
‚ñ† Top Bar: Fixed controls for nodes, project management, AI tools, user profile.
‚ñ† Bottom Bar: Fixed status area with zoom controls, build progress, and a minimap toggle.
‚ñ† Left Panel: Rete.js canvas for visual node editing (resizable).
‚ñ† Right Panel: Tab container for AI chat, notebook, logs, timeline, and properties (resizable).

## üìö Libraries To Use
Vue 3 (Composition API)
Rete.js (https://retejs.org/)
Bootstrap 5 (https://getbootstrap.com/)
Vue Router (for navigation)
Vuex / Tiny Emitter (eventBus) (for state management if needed)
FontAwesome (for icons)

## üìÅ Folder structure for frontend:
/src
/components
/views
/public
App.vue
main.js

## üñ±Ô∏è Component Structure

### 2. Top Bar (Fixed Header)
User menu 
File: components/TopBar.vue buttons:
Project Controls: New, Open, Save, Export, Build, Run, Publish.
Node Controls: Add Node, Clear, Group, Ungroup, Lock, Unlock.
Search button

### 3. Create Bottom Bar (Fixed Footer)
File: components/BottomBar.vue
‚ñ† Selected Node Status
‚ñ† Arrage nodes
‚ñ† Build Progress Bar
‚ñ† üí° Minimap Toggle Button (show/hide minimap component)
‚ñ† Use Bootstrap's fixed-bottom class for positioning.

### 4. Create Left Panel (Resizable Rete.js Canvas)
File: components/LeftPanel.vue
Render Rete.js editor canvas.
This panel is where nodes are displayed and manipulated.

### 5. Create Right Panel (floating panel)
File: components/RightPanel.vue
Use Bootstrap nav-tabs for tabs:
‚ñ† AI Chat: Interactive chat UI
‚ñ† Logs: Real-time logs
‚ñ† Properties: Selected node configuration panel
‚ñ† Files

### 7. Assemble Main Editor View
File: views/MainEditor.vue
Combine TopBar, BottomBar, LeftPanel, RightPanel into a responsive layout

### 8. App.vue
Load MainEditor.vue.
Setup Vue Router if needed for additional pages.

## Useful Components and Patterns

### API Plugin
‚ñ† api-plugin already has all functions of crud by using axios and bearer token. Use this plugin by calling const api=inject('api'). The available functions are get, put, delete, post. Pass the parameters as same with axios function. 
‚ñ† **Important: Don't use axios directly in components or services.** All HTTP requests should use the api plugin which automatically handles authentication headers.
‚ñ† **For services**: Service classes should have a `setApi(api)` method. Components must inject the api and call `service.setApi(api)` before using the service:
  ```javascript
  // In component setup()
  const api = inject('api');
  someService.setApi(api);
  ```
‚ñ† **IMPORTANT: Never send firebaseUid to backend**. The backend extracts user identity from the JWT token in the Authorization header automatically. The api-plugin handles authentication headers, so you don't need to manage firebaseUid manually.

## üìù Keep It Simple
Each Vue component should be self-contained.
Avoid over-engineering or unnecessary abstractions.
No backend logic is needed; use mock data for testing UI.
Use clear naming conventions for props and events.
Use eventBus instead of watch

## ‚úÖ Important Notes

-  Focus only on frontend UI layout and interactions.
-  Use mock data for node status and AI chat until backend is ready.
-  Minimap toggle must dynamically show/hide the minimap overlay.
-  Strictly use only bootstrap 5 for styling and layout. do not introduce other CSS frameworks. do not use custom CSS.
-  Ensure all components are responsive and work well on different screen sizes.
-  Do not use camelCase for data from backend, keep it as it is, properly data from backend uses PascalCase.
-  I don't like outlines on buttons or any components if it's not necessary. i prefer shadow effects.

---

# Data Layer Instructions (NodPT.Data)

Shared data access layer using DevExpress XPO (eXpress Persistent Objects) for object-relational mapping with MySQL/MariaDB database.

## üõ†Ô∏è Technology Stack

-  **DevExpress XPO 25.1.3**: Object-Relational Mapping framework
-  **.NET 8.0**: Target framework
-  **MySQL/MariaDB**: Primary database
-  **Unit of Work Pattern**: Transaction management

## üèóÔ∏è Architecture

### Data Access Layers

```
Controllers/Services
    ‚îÇ
    ‚ñº
Unit of Work
    ‚îÇ
    ‚ñº
XPO Session
    ‚îÇ
    ‚ñº
MySQL Database
```

## üìù Usage

### Unit of Work Pattern

The recommended approach for data service:

```csharp
public class YourService
{
    private readonly UnitOfWork _unitOfWork;
    private User _user;

    // pass the UnitOfWork via DI
    public YourService(UnitOfWork unitOfWork)
    {
        _unitOfWork = unitOfWork;
    }

    // RECOMMENDED: Accept ClaimsPrincipal or User in constructor for automatic user validation
    public YourService(UnitOfWork unitOfWork, ClaimsPrincipal claimsPrincipal)
    {
        _unitOfWork = unitOfWork;
        _user = UserService.GetUser(claimsPrincipal, unitOfWork);

        // Validate user at constructor level
        if (_user == null)
        {
            throw new UnauthorizedAccessException("User is not authorized or not found");
        }
    }

    // Alternative: Accept User directly
    public YourService(UnitOfWork unitOfWork, User user)
    {
        _unitOfWork = unitOfWork;
        _user = user;

        if (_user == null)
        {
            throw new ArgumentNullException(nameof(user));
        }
    }

    public async Task<DataClass> UpdateData(int id, DataDto dto)
    {
        // User is already validated in constructor, so you can use it directly
        var data = await _unitOfWork.FindObject<DataClass>(id);
        if (data == null)
            throw new KeyNotFoundException("Data not found");

        data.DisplayName = dto.DisplayName;
        data.UpdatedAt = DateTime.UtcNow;

        data.Save();
        await _unitOfWork.CommitAsync();

        return data;
    }
}
```

## üîë Authentication & User Management

### Getting Current User from Context

**IMPORTANT**: Always use `UserService.GetUser(ClaimsPrincipal)` to get the current user from the Context.User. **NEVER** require firebaseUid from frontend clients.

```csharp
// In controller or service:
var user = UserService.GetUser(User, unitOfWork);

if (user == null)
{
    // Return unauthorized or throw exception
    throw new UnauthorizedAccessException("User is banned, not approved, or not found");
}

// Use the user object for all operations
user.Projects.Add(newProject);
```

### UserService Methods

```csharp
// Get User entity from ClaimsPrincipal (Context.User)
// Returns null if user is not found, banned, or not approved
User? user = UserService.GetUser(ClaimsPrincipal user, UnitOfWork session);

// Check if user is valid (active, approved, not banned)
bool isValid = UserService.IsUserValid(string firebaseUId, UnitOfWork session);

// Get Firebase UID from ClaimsPrincipal
string? firebaseUid = UserService.GetFirebaseUIDFromContent(ClaimsPrincipal user);
```

### Service Layer Pattern with User Validation

Services should accept `ClaimsPrincipal` or `User` in their constructor to enable automatic user validation at the service layer instead of controller layer:

```csharp
// Example: ProjectService
public class ProjectService
{
    private readonly UnitOfWork _unitOfWork;
    private readonly User _user;

    public ProjectService(UnitOfWork unitOfWork, ClaimsPrincipal claimsPrincipal)
    {
        _unitOfWork = unitOfWork;
        _user = UserService.GetUser(claimsPrincipal, unitOfWork);

        if (_user == null)
        {
            throw new UnauthorizedAccessException("User not authorized");
        }
    }

    public ProjectDto CreateProject(ProjectDto projectDto)
    {
        // No need to pass firebaseUid or validate user here
        // User is already validated in constructor

        var project = new Project(_unitOfWork)
        {
            Name = projectDto.Name,
            Description = projectDto.Description,
            User = _user, // Use the validated user
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        _unitOfWork.Save(project);
        _unitOfWork.CommitTransaction();

        return MapToDto(project);
    }

    public List<ProjectDto> GetUserProjects()
    {
        // Get projects for the validated user
        return _user.Projects
            .Where(p => p.IsActive)
            .Select(p => MapToDto(p))
            .ToList();
    }
}
```

### XPO Associations and Navigation Properties

**IMPORTANT**: Always use XPO's `Association` attribute to define relationships between entities. Use proper collection types and GetCollection method for accessing related entities.

#### Defining Associations in Models

```csharp
public class User : XPObject
{
    // One-to-Many: User has many Projects
    [Association("User-Projects")]
    public XPCollection<Project> Projects
    {
        get { return GetCollection<Project>(nameof(Projects)); }
    }
}

public class Project : XPObject
{
    // Many-to-One: Project belongs to User
    private User _user;
    [Association("User-Projects")]
    public User User
    {
        get { return _user; }
        set { SetPropertyValue(nameof(User), ref _user, value); }
    }

    // One-to-Many: Project has many Nodes
    [Association("Project-Nodes")]
    public XPCollection<Node> Nodes
    {
        get { return GetCollection<Node>(nameof(Nodes)); }
    }
}

public class Node : XPObject
{
    // Many-to-One: Node belongs to Project
    private Project _project;
    [Association("Project-Nodes")]
    public Project Project
    {
        get { return _project; }
        set { SetPropertyValue(nameof(Project), ref _project, value); }
    }
}
```

#### Using Navigation Properties

```csharp
// Access related Projects directly from User entity
var user = UserService.GetUser(User, unitOfWork);
var activeProjects = user.Projects
    .Where(p => p.IsActive)
    .ToList();

// get a specific project
var project = user.Projects
    .FirstOrDefault(p => p.Id == projectId);

// or create new Project
var newProject = new Project(unitOfWork)
{
    Name = "New Project",
    User = user, // set the owner - association handles the relationship
    CreatedAt = DateTime.UtcNow,
    UpdatedAt = DateTime.UtcNow
};
unitOfWork.Save(newProject);
unitOfWork.CommitTransaction();
// Note: No need to manually add to user.Projects, the Association handles it

// get nodes from a project using navigation property
var nodes = user.Projects
    .FirstOrDefault(p => p.Id == projectId)?
    .Nodes
    .Where(n => n.IsActive)
    .ToList();
```

## üõ†Ô∏è Development Guidelines

### Best Practices

1. **Always use UserService.GetUser()**: Get user from Context.User, don't accept firebaseUid from clients
2. **Validate at Service Layer**: Pass ClaimsPrincipal to service constructor for automatic validation
3. **Use Unit of Work**: Ensures proper transaction management
4. **Async operations**: Use async methods for all database operations
5. **Proper disposal**: UnitOfWork is scoped, let DI handle disposal
6. **Validation**: Validate data before saving
7. **Indexes**: Add indexes to frequently queried columns
8. **Relationships**: Use XPO associations for foreign keys

### Naming Conventions

-  **Tables**: PascalCase, plural (Users, Projects, Workflows)
-  **Columns**: PascalCase (DisplayName, CreatedAt)
-  **Properties**: PascalCase (user.DisplayName)
-  **Foreign Keys**: Singular + Id (OwnerId, ProjectId)

## üîí Security

### SQL Injection Prevention

XPO uses parameterized queries automatically:

```csharp
// Safe - XPO handles parameterization
var user = new XPQuery<User>(session)
    .FirstOrDefault(u => u.Email == userInputEmail);
```

### User Authorization

Always check user permissions before performing operations:

```csharp
// Get current user from Context
var currentUser = UserService.GetUser(User, unitOfWork);

if (currentUser == null)
{
    return Unauthorized("User not found or not authorized");
}

// Check if user owns the resource
if (resource.User.Oid != currentUser.Oid && !currentUser.IsAdmin)
{
    return Forbid("You don't have permission to access this resource");
}
```

## üìö Resources

-  [DevExpress XPO Documentation](https://docs.devexpress.com/XPO/1998/express-persistent-objects)
-  [XPO Best Practices](https://docs.devexpress.com/XPO/2034/best-practices)
-  [MySQL Documentation](https://dev.mysql.com/doc/)

---

# WebAPI Instructions

## üìÑ Overview
This project builds a visual AI-assisted workflow editor backend using web api .NET 8.0
The goal is to create a clean, modular web api.
Data models will be simple, focusing on nodes and other data. Using XPO ORM database for persistence.

Keep the code clean, modular, and easy to understand. Use mock data for initial development. don't overthink the logic, keep it simple.

## üß± Backend Setup Guide (ASP.NET Core Web API)

### üõ†Ô∏è Step 1: Create a New ASP.NET Core Web API Project

### üìÅ Step 2: Organize Project Structure

Create folders to keep things clean:

```
/Controllers
/Models
/Services
/Data
```

---

### üß© Step 3: Define Models

Create simple models to simulate data:

**Models/Node.cs**

```csharp
public class Node: XPLiteObject
{
    public string Id { get; set; }
    public string Name { get; set; }
    public NodeType NodeType { get; set; } // e.g., "active", "locked"
    public Dictionary<string, string> Properties { get; set; }
    public XPCollection<ChatMessage> ChatMessages { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    public string Status { get; set; } // e.g., "active", "locked"
    public Node? PanelRawNode { get; set; } // For grouping nodes
    public XPCollection<Node> Children { get; set; } // for grouping nodes
}
```

**Models/ChatMessage.cs**

```csharp
public class ChatMessage: XPObject
{
    public string Sender { get; set; } // user or AI
    public string Message { get; set; }
    public DateTime Timestamp { get; set; }
    public bool MarkedAsSolution { get; set; } // For marking messages as solutions
    public Node Node { get; set; } // Reference to the node this message belongs
    public bool Liked { get; set; } // For user feedback
    public bool Disliked { get; set; } // For user feedback
}
```

---

### üß† Step 4: Create Mock Services

**Services/NodeService.cs**

```csharp
public class NodeService
{
    private static List<Node> _nodes = new()
    {
        new Node { Id = "1", Name = "Start", Status = "active", Properties = new() },
        new Node { Id = "2", Name = "Process", Status = "locked", Properties = new() }
    };

    public List<Node> GetAllNodes() => _nodes;
    public Node? GetNode(string id) => _nodes.FirstOrDefault(n => n.Id == id);
}
```

**Services/ChatService.cs**

```csharp
public class ChatService
{
    private static List<ChatMessage> _messages = new();

    public List<ChatMessage> GetMessages() => _messages;

    public void AddMessage(ChatMessage message)
    {
        _messages.Add(message);
    }
}
```

---

### üß≠ Step 5: Create Controllers

**Controllers/NodesController.cs**

```csharp
[ApiController]
[Route("api/[controller]")]
public class NodesController : ControllerBase
{
    private readonly NodeService _nodeService = new();

    [HttpGet]
    public IActionResult GetNodes() => Ok(_nodeService.GetAllNodes());

    [HttpGet("{id}")]
    public IActionResult GetNode(string id)
    {
        var node = _nodeService.GetNode(id);
        return node == null ? NotFound() : Ok(node);
    }
}
```

**Controllers/ChatController.cs**

```csharp
[ApiController]
[Route("api/[controller]")]
public class ChatController : ControllerBase
{
    private readonly ChatService _chatService = new();

    [HttpGet]
    public IActionResult GetMessages() => Ok(_chatService.GetMessages());

    [HttpPost]
    public IActionResult PostMessage([FromBody] ChatMessage message)
    {
        _chatService.AddMessage(message);
        return Ok();
    }
}
```

---

### üîß Step 6: Enable CORS for Frontend

In `Program.cs`:

```csharp
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", policy =>
    {
        policy.AllowAnyOrigin()
              .AllowAnyHeader()
              .AllowAnyMethod();
    });
});

var app = builder.Build();
app.UseCors("AllowAll");
```

---

### üöÄ Step 8: Run and Test

1. Run the backend.
2. Use Postman or your Vue frontend to test endpoints:
   - `GET /api/nodes`
   - `GET /api/nodes/{id}`
   - `GET /api/chat`
   - `POST /api/chat`

---

### ‚úÖ Final Notes

- Keep logic simple and clean.
- Use mock data until real database or AI integration is needed.
- You can later add endpoints for:
  - Build progress
  - Timeline rollback
  - Node grouping/locking
  - AI tool interactions

Would you like me to generate a sample `.http` file or Postman collection to test these endpoints?

---

## üìä Logging Pattern

All controllers should implement error logging using the following pattern:

**Models/Log.cs**

```csharp
public class Log : XPObject
{
    public string? ErrorMessage { get; set; }
    public string? StackTrace { get; set; }
    public string? Username { get; set; }
    public DateTime Timestamp { get; set; }
    public string? Controller { get; set; }
    public string? Action { get; set; }
}
```

**Controllers Pattern with Dependency Injection**

Controllers should use dependency injection for UnitOfWork and LogService, and wrap all methods with try-catch blocks:

```csharp
[ApiController]
[Route("api/[controller]")]
public class ProjectsController : ControllerBase
{
    private readonly UnitOfWork unitOfWork;
    private readonly LogService _logService;

    public ProjectsController(UnitOfWork _unitOfWork, LogService logService)
    {
        this.unitOfWork = _unitOfWork;
        this._logService = logService;
    }

    [HttpGet]
    public IActionResult GetProjects()
    {
        try
        {
            // Your logic here
            return Ok(result);
        }
        catch (Exception ex)
        {
            _logService.LogError(ex.Message, ex.StackTrace, User?.Identity?.Name, "ProjectsController", "GetProjects");
            return StatusCode(500, new { error = "An error occurred." });
        }
    }
}
```

**Service Registration**

Register services in Program.cs:

```csharp
builder.Services.AddScoped<LogService>();
```

**LogController**

The LogController exposes all logged errors via GET request:

```csharp
[ApiController]
[Route("api/[controller]")]
public class LogsController : ControllerBase
{
    private readonly LogService _logService;

    public LogsController(LogService logService)
    {
        _logService = logService;
    }
    [HttpGet]
    public IActionResult GetLogs() => Ok(_logService.GetAllLogs());
}
```

Access logs at: `GET /api/logs`

---

## üîë Controllers and WebAPI Integration

Controllers should use dependency injection for UnitOfWork and pass `User` (ClaimsPrincipal) to service constructors. Services handle user validation (see Data Layer Instructions).

```csharp
[ApiController]
[Route("api/[controller]")]
public class ProjectsController : ControllerBase
{
    private readonly UnitOfWork unitOfWork;
    
    public ProjectsController(UnitOfWork _unitOfWork)
    {
        this.unitOfWork = _unitOfWork;
    }
    
    [HttpPost]
    public IActionResult CreateProject([FromBody] ProjectDto projectDto)
    {
        try
        {
            // Service validates user in constructor (Data layer)
            var service = new ProjectService(unitOfWork, User);
            var project = service.CreateProject(projectDto);
            return Ok(project);
        }
        catch (UnauthorizedAccessException ex)
        {
            return Unauthorized(new { error = ex.Message });
        }
        catch (Exception ex)
        {
            LogService.LogError(ex.Message, ex.StackTrace, User?.Identity?.Name, "ProjectsController", "CreateProject");
            return StatusCode(500, new { error = "An error occurred." });
        }
    }
    
    [HttpGet]
    public IActionResult GetProjects()
    {
        try
        {
            // Service validates user and returns their projects
            var service = new ProjectService(unitOfWork, User);
            var projects = service.GetUserProjects();
            return Ok(projects);
        }
        catch (UnauthorizedAccessException ex)
        {
            return Unauthorized(new { error = ex.Message });
        }
    }
}
```

**IMPORTANT**: Controllers should **NOT** accept firebaseUid as a parameter from the frontend. User identity is extracted from JWT token in Authorization header by the UserService in the Data layer.

```csharp
// ‚ùå BAD - Don't do this
[HttpGet("user/{firebaseUid}")]
public IActionResult GetProjectsByUser(string firebaseUid)
{
    // This allows users to access other users' data
}

// ‚úÖ GOOD - Do this instead
[HttpGet]
public IActionResult GetProjects()
{
    try
    {
        var service = new ProjectService(unitOfWork, User);
        var projects = service.GetUserProjects();
        return Ok(projects);
    }
    catch (UnauthorizedAccessException)
    {
        return Unauthorized(new { error = "User not authorized" });
    }
}
```
